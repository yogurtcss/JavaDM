package pers.yo.adv1.demo05_Extends;

/* 局部变量、本类(即子类)的成员变量与 父类的成员变量 三者重名，打印结果情况如何？
* 局部变量：方法内的局部变量，直接按普通写法来写即可
* 本类(即子类)的成员变量：  this.成员变量名
* 父类的成员变量：         super.成员变量名
*
*
* 父类与子类的方法名重名，使用成员方法method的规则：
*    看看创建此实例对象s时 等号右边是谁(就是看 由谁new出来的！)，实例对象就优先用谁的成员方法method；没有则向(上一辈，如父亲)上找
*
*
* 【对比记忆嗷！Demo01ExtendsVar.java的笔记！】 注：直接通过子类对象(.点号)访问成员变量时，是看 等号左边是谁！！
* ▲直接通过子类对象(.点号)访问成员变量：
*     看看创建此实例对象s时 等号左边是谁(不能看是由谁new出来的！)，实例对象就优先用谁的成员变量；没有则向(上一辈，如父亲)上找
* 【特别注意！】 Father sX = new Son(); //这时候还是要看 等号左边是谁！(不能看是由谁new出来的！)这里等号左边是Father，实例对象sX用的是Father的成员变量！
*
*
* 注：无论是成员方法还是成员变量，如果子类中没有，都是向(上一辈，如父亲)上找，
* 绝不会向下找的(因为该子类也不知道它的下一辈儿子是谁，不知道被谁继承了)
*
* 重写(Over-ride)：在继承关系的父、子类中，方法名一样，参数列表也一样
* 重载(Over-load)：方法名一样，参数列表 不一样
* 重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。
*
*  */

public class Demo01ExtendsMethod {
    public static void main(String[] args) {
        Father f = new Father();
        Son s1 = new Son();
        s1.method_Var_DoubleName(); //局部变量、本类(即子类)的成员变量与 父类的成员变量 三者重名，打印结果情况如何？
        s1.method_DoubleName(); //父类与子类的方法名重名，使用成员方法method的规则如何？
    }
}
