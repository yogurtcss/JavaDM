package pers.yo.adv1.demo16_Thread;

import pers.yo.adv1.demo16_Thread.Person;

/*
Java中：创建线程法1：继承 Thread 类  【java.lang.Thread】
1.定义 Thread 类的子类A，并重写该类的 run()方法
   - 该run()方法中的方法体，代表了此线程需要完成的任务；故称run() 方法为线程执行体
2.创建 Thread 类的子类A的实例对象（即创建了线程对象）
3.调用线程对象的 start() 方法来启动该线程

-------------------------------------------------
创建线程法2：Runnable接口( Runnable 可运行的、“任务” )  【java.lang.Runnable】
1.定义 Runnable接口 的实现类，并重写该接口的run()方法
   - 该run()方法中的方法体，也是代表了此线程需要完成的任务；——故称run() 方法为线程执行体
2.【创建子任务实例r】创建 Runnable接口 的实现类 的【实例对象】为r(记为 子任务r)
3.【关键：传递子任务r，并生成真正的线程对象】把 上述的子任务r 作为 父类Thread的形参(即target)，以创建 父类Thread的实例对象——真正的线程对象

-------------------------------------------------
以上两种创建线程方式的对比
1.采用 【继承Thread类的方式】 创建多线程时：
优势：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread () 方法，直接使用 this 即可获得当前线程。
劣势：当前线程类已经继承了 Thread 类，所以不能再继承其他父类。

2.采用 【实现Runnable、Callable接口的方式】 创建多线程时，
优势：(1)当前线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类、还可以实现其他接口
(2)在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，
从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

劣势：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread () 方法。


*  */


public class Demo01Thread {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.start(); //创建线程p1，“就绪”完毕后，自动执行此线程p1的run方法

        /* 创建完 Thread 对象后线程并没有启动，直到调用了 start 方法才真正启动。
        那么问题就来了，我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
        我们new一个 Thread，线程就进入了新建状态，
        而调用了 start 方法之后它才会进入就绪状态，等待CPU时间片的分配；
        就绪状态 + 时间片 = 线程真正运行，它会自动执行 run 方法。
        ▲ 如果直接调用run方法，main线程会把它当做一个普通的方法去执行，这不是多线程工作（仍然在主线程执行）。
        *  */
//        p1.run(); //如果直接调用run方法，main线程会把它当做一个普通的方法去执行，这不是多线程工作（仍然在主线程执行）。

        for( int i=0; i<20; i++ ){ //主线程中的for循环
            System.out.println( "main线程："+i );
        }
        /* p1.start()，即p1线程中的for循环
        *
        * java程序属于抢占式调度：优先级高的线程，优先执行；若线程优先级相同，则随机选一个线程执行
        * p1线程和主线程抢夺CPU的执行权(执行时间)；谁抢到了，谁就执行其对应的代码
        *
        * 在线程的内存图中：每执行一次 （不同的）线程实例对象.start() 方法，就会为此线程对象开辟新的栈空间，等待执行此线程对象的run()方法
        * 如：p1.start() ：为此线程对象p1开辟新的栈空间，等待执行此线程对象p1的run()方法；
        * p2.start() ：为此线程对象p2开辟新的栈空间，等待执行此线程对象p2的run()方法；
        * p3.start() ：为此线程对象p3开辟新的栈空间，等待执行此线程对象p3的run()方法；
        *
        * p1、p2、p3抢夺CPU的执行权，谁抢到了，谁就执行其对应的代码
        *  */

    }
}
