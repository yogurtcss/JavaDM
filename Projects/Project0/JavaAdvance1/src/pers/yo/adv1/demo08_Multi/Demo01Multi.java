package pers.yo.adv1.demo08_Multi;

/* 面向对象三大特征：封装性、继承性、多态性
* extends继承 或 implements实现，是多态性的前提
* 一个(实例)对象拥有多种形态，这就是 对象的多态性，作用：扩展方便
*
* 代码中体现多态性：父类引用指向子类对象
*
* 多态存在 有三个必要条件：
* 1.要有继承；
* 2.要有重写；
* 3.父类引用指向子类对象。
*
* 解释：父类引用指向子类对象
* 最终多态体现为 (左侧)父类引用变量可以指向(右侧)子类对象：
* 父类名 变量名 = new 子类名();      或者
* 接口名 变量名 = new 实现类的名称();
*
*
* 首先理解 “向上转型”。
* 已知：我定义了一个子类 Cat，令它继承了 Animal 类，
* Animal a = new Cat(); 是什么意思？ //创建了一只猫，它被当作动物看待，没问题嗷！
* 它表示我定义了一个 Animal 类型的引用，指向新建的 Cat 类型的对象。(等号理解为“指向”)
* 由于 Cat 是继承自它的父类 Animal，【隐藏的已知条件嗷！】--指向Cat相当于指回Animal了
* 所以 Animal 类型的引用是可以指向 Cat 类型的对象的。这就是 “向上转型” —— 即把子类类型对象转成了父类类型。
*
* 向上转型的好处是隐藏了子类类型，提高了代码的扩展性。
* 但向上转型也有弊端，只能使用父类共性的内容，而无法使用子类特有功能、特有属性，使得功能有限制。
*
* 向上转型一定是安全的——因为它从小范围转向了大范围
*
* 上转型对象不能调用 【子类新增的(即 子类独有的)】属性和方法，只能调用子类继承和隐藏的属性、子类继承和重写的方法；解释如下
*   -属性：子类中与父类同名的属性也算作 【子类新增(即 子类独有的)属性】，不能被调用。
*         所以我们在程序中显示调用的那个同名属性事实上是属于父类的被隐藏的属性，输出值当然会是父类的值。
*
*          ▲直接通过子类对象(.点号)访问成员变量：
*             看看创建此实例对象s时 等号左边是谁(不能看是由谁new出来的！)，实例对象就优先用谁的成员变量；没有则向(上一辈，如父亲)上找
*         ▲间接通过成员方法(method)访问成员变量：
*           看看该方法(method) 属于谁(哪个类)，就优先用谁的成员变量；没有则向(上一辈，如父亲)上找
*
*
*
*  -方法：上转型对象调用的方法，要么是被子类重写过的方法，要么是直接从父类那继承未被重写的方法，不可能是隐藏方法。
*        联想记忆：调用实例的成员方法时，看等号右边new的是谁，就调用谁的成员方法；若没有则向上找。这恰好与 【上转型对象调用的方法】的规则是相同的
*        多态的代码中：调用成员方法的口诀：等号放中间，编译看左边，运行看右边
*        多态的代码中：调用成员变量的口诀：等号放中间，编译看左边，运行还看左边
*
* --------------------------------------------------------------------------------
* 向下转型——【还原】 将父类实例对象，还原称为原本的子类实例对象
* 本来是猫，被上转型为“动物”，现又被还原回猫了
* 可理解为 引用类型的强制类型转换，格式为：
* 子类名 变量名 = (子类名) 父类的实例对象名
*
* 举例。假设 Cat 继承于 Animal：
* Animal animal = new Cat(); //本来是猫，向上转型成为“动物”
* Cat cat = (Cat) animal; //本来是猫，已经被当作“动物”了，现还原回来成为原本的猫
*
*  */

import pers.yo.adv1.demo08_Multi.Fu;
import pers.yo.adv1.demo08_Multi.Zi;

public class Demo01Multi {
    public static void main(String[] args) {
        Fu f = new Zi(); //左侧父类引用，指向了右侧子类实例对象
        f.method(); //调用实例的成员方法时，看等号右边new的是谁，就调用谁的成员方法；若没有则向上找；这恰好与 【上转型对象调用的方法】的规则是相同的
//        f.methodZi(); //上转型对象不能调用子类新增的(子类独有的)方法(在这里是 methodZi)

        Zi z1 = (Zi) f; //向下转型，还原回 “子Zi” ，则可调用 子类新增的(子类独有的)方法(在这里是 methodZi)
        z1.methodZi();
        System.out.println( "-------------------------------------" );

        /* 实例X instanceof 某类Y
        * 测试它左边的对象X是否为 它右边的类Y的实例，返回boolean的数据类型
        *  */
        if( f instanceof Zi ){ //判断 父类引用f 原本是不是Zi
            Zi z2 = (Zi)f; //若是，则向下转型，并调用 子类新增的(子类独有的)方法(在这里是 methodZi)
            z2.methodZi();
        }

    }
}
